--- a/snake/agent.py
+++ b/snake/agent.py
@@ -468,6 +468,12 @@
             if food is not None and urgency > 0.0:
                 d_after = abs(next_head[0] - food[0]) + abs(next_head[1] - food[1])
                 score += reward_scale * 4.0 * urgency * float(base_food_dist - d_after)
 
+            # Always provide a small "progress-to-food" signal to reduce dithering
+            # when life is high (prevents repeatedly dodging the last step).
+            if food is not None:
+                d_after = abs(next_head[0] - food[0]) + abs(next_head[1] - food[1])
+                score += reward_scale * 1.5 * float(base_food_dist - d_after)
+
             # Simulate and evaluate topology.
             sim_snake, ate = self._simulate_step(snake, move, food)
             reachable, _total_open, tail_ok, pocket = self._escape_metrics(sim_snake, ate_food=ate)
             pocket_delta_raw = pocket - baseline_pocket
@@ -489,12 +495,26 @@
             # - Non-eat moves: allow temporary disconnection if head component remains comfortably large,
             #   but avoid creating large new pockets while disconnected.
             reason = None
             if ate:
-                if reachable >= (len(sim_snake) + int(self.eat_reach_slack)):
-                    ok = True
-                else:
-                    ok = False
-                    reason = "eat_space"
+                # Primary: conservative check (tail does not move on eat tick).
+                ok = reachable >= (len(sim_snake) + int(self.eat_reach_slack))
+                if not ok:
+                    # Secondary: "one tick later" check (tail will move next tick).
+                    # This prevents safe corner/corridor eats from being vetoed purely
+                    # because the tail didn't advance on the eat step.
+                    reachable_future, _to, _tail_ok_future, _pocket_future = self._escape_metrics(
+                        sim_snake, ate_food=False
+                    )
+                    ok = reachable_future >= (len(sim_snake) + 1)
+                if not ok:
+                    reason = "eat_space"
+                else:
+                    # If we can safely eat, prefer it.
+                    score += reward_scale * float(config.REWARD_FOOD)
             else:
                 tail_condition = tail_ok
                 open_condition = reachable >= (len(sim_snake) + 2)
                 ok = tail_condition or open_condition
@@ -531,7 +551,7 @@
             pocket_delta_eff = max(0, int(pocket_delta) - int(allow))
 
             score -= self.pocket_penalty * penalty_scale * float(pocket)
-            score -= self.pocket_delta_penalty * penalty_scale * float(pocket_delta_eff) * (2.0 if ate else 1.0)
+            score -= self.pocket_delta_penalty * penalty_scale * float(pocket_delta_eff) * (1.25 if ate else 1.0)
